<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roy R. Liu | Portfolio</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #040503; }
        /* Move brightness to CSS for 10x better performance */
        canvas { display: block; filter: brightness(0.9); } 
        #header {
            position: absolute; top: 40px; width: 100%; text-align: center;
            color: #d0d0d0; font-family: 'Georgia', serif; font-style: italic;
            letter-spacing: 2px; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>

<div id="header"><h1>Welcome to my webpage.</h1></div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// --- SETTINGS ---
const LEAF_COUNT = 2800; // Balanced for high-density + speed
const HORIZON_RATIO = 0.45; 
const BOTTOM_MARGIN = 0.1;  
const GRAVITY = 0.42;
const DOG_W = 32, DOG_H = 40;

let mouse = { x: 0, y: 0 };
let dog = { x: 200, y: 0, vx: 0, vy: 0, row: 1, col: 0, facing: 'right', sitLock: false };
let leaves = [];
let icons = [];
let lastTime = 0;

const assets = {
    dog: { src: 'assets/dog.png', img: new Image() },
    fallLeaf: { src: 'assets/fall_leaf.png', img: new Image() },
    springLeaf: { src: 'assets/spring_leaf.png', img: new Image() }
};

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
    dog.y = canvas.height * 0.7;

    for(let i=0; i<LEAF_COUNT; i++) {
        leaves.push({
            x: Math.random() * canvas.width,
            y: topLimit + Math.random() * (botLimit - topLimit),
            z: 0, vz: 0, vx: 0, vy: 0,
            rotX: Math.random() * 6, rotY: Math.random() * 6, vrX: 0,
            type: Math.random() > 0.5 ? 'fallLeaf' : 'springLeaf',
            frame: Math.floor(Math.random()*5),
            size: 42 + Math.random() * 45, 
            waftSeed: Math.random() * 100,
            layer: Math.random(),
            chaos: 0.7 + Math.random() * 0.6
        });
    }
    
    Object.keys(assets).forEach(k => assets[k].img.src = assets[k].src);
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', triggerSit);
    requestAnimationFrame(loop);
}

function triggerSit(e) {
    if (dog.sitLock) return;
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
    if (e.clientY < topLimit || e.clientY > botLimit) return;

    dog.sitLock = true;
    dog.vx = 0; dog.vy = 0;
    
    // Scuff physics sit effect
    for(let l of leaves) {
        let dx = l.x - dog.x, dy = l.y - dog.y;
        let dSq = dx*dx + dy*dy;
        if (dSq < 8100) { // 90px radius
            let angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.4;
            l.vx += (Math.cos(angle) * 0.8) + (Math.random() - 0.5);
            l.vz += (5.5 + Math.random() * 4) * 0.64; // Re-applied 0.8x twice for balance
            l.vrX = (Math.random() - 0.5) * 0.2;
            l.layer = 1.0;
        }
    }
    setTimeout(() => { dog.sitLock = false; }, 1200);
}

function loop(time) {
    const dt = Math.min((time - lastTime) / 16.67, 1.5) || 1;
    lastTime = time;
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);

    // Optimized Clear
    ctx.fillStyle = '#040503'; ctx.fillRect(0, 0, canvas.width, topLimit);
    ctx.fillStyle = '#0d100a'; ctx.fillRect(0, topLimit, canvas.width, botLimit - topLimit);
    ctx.fillStyle = '#000000'; ctx.fillRect(0, botLimit, canvas.width, canvas.height - botLimit);

    // Dog Logic
    let targetY = Math.max(topLimit + 5, Math.min(botLimit - 5, mouse.y));
    let dx = mouse.x - dog.x, dy = targetY - dog.y;
    let distSq = dx*dx + dy*dy;

    if (!dog.sitLock) {
        if (distSq > 10000) { // Dead zone 100px
            dog.vx = dx * 0.05; dog.vy = dy * 0.05;
        } else {
            dog.vx *= 0.8; dog.vy *= 0.8;
        }
        dog.facing = (mouse.x > dog.x) ? 'right' : 'left';
    }
    dog.x += dog.vx * dt; dog.y += dog.vy * dt;

    // Sprite selection
    let moving = dog.vx*dog.vx + dog.vy*dog.vy > 0.5;
    if (dog.sitLock) { dog.row = 3; dog.col = (dog.facing==='right'?0:2) + (Math.floor(time/300)%2); }
    else if (!moving) { dog.row = 1; dog.col = (dog.facing==='right'?0:2) + (Math.floor(time/500)%2); }
    else { dog.row = (dog.facing==='right'?6:7); dog.col = Math.floor(time/100)%4; }

    // Leaf Update & Render
    // We combine loops for speed
    const renderList = [];
    const dogX = dog.x, dogY = dog.y;

    for (let i = 0; i < LEAF_COUNT; i++) {
        let l = leaves[i];
        
        // Physics update (only if airborne or moving)
        if (l.z > 0 || Math.abs(l.vx) > 0.1) {
            l.x += l.vx * dt; l.y += l.vy * dt; l.z += l.vz * dt;
            if (l.z > 0) {
                l.vz -= GRAVITY * dt;
                if (l.vz < 0) { // Falling (waft)
                    l.vx *= 0.94; l.vx += Math.sin(time*0.002 + l.waftSeed) * 0.2 * l.chaos;
                } else { l.vx *= 0.99; l.vrX *= 0.96; }
            } else { l.z = 0; l.vz = 0; l.vx *= 0.6; l.vy *= 0.6; l.vrX = 0; }
            
            // Boundary bounce
            if (l.x < 0 || l.x > canvas.width) l.vx *= -0.5;
            if (l.y < topLimit || l.y > botLimit) l.vy *= -0.5;
        }

        // Collision Check (Culled by distance for performance)
        let dSq = (l.x-dogX)*(l.x-dogX) + (l.y-dogY)*(l.y-dogY);
        if (dSq < 2500 && moving && !dog.sitLock) {
            if (l.layer > 0.7 && Math.random() > 0.5) {
                l.vz += (0.07 + Math.sqrt(dog.vx*dog.vx + dog.vy*dog.vy)*0.04) * 0.8;
                l.vx += (l.x - dogX) * 0.05;
                l.layer = Math.min(1.0, l.layer + 0.1);
            }
        }
        renderList.push(l);
    }

    renderList.push('DOG');
    renderList.sort((a,b) => (a==='DOG'?dog.y:a.y) - (b==='DOG'?dog.y:b.y));

    for (let obj of renderList) {
        if (obj === 'DOG') {
            if (assets.dog.img.complete) {
                let p = 0.5 + (dog.y/canvas.height);
                ctx.drawImage(assets.dog.img, dog.col*DOG_W, dog.row*DOG_H, DOG_W, DOG_H, dog.x-(135*p/2), dog.y-(160*p*0.7), 135*p, 160*p);
            }
        } else {
            if (assets[obj.type].img.complete) {
                let p = 0.5 + (obj.y/canvas.height);
                ctx.setTransform(p * Math.sin(obj.rotX), 0, 0, p * Math.cos(obj.rotY), obj.x, obj.y - obj.z);
                ctx.drawImage(assets[obj.type].img, obj.frame*16, 0, 16, 16, -obj.size/2, -obj.size/2, obj.size, obj.size);
                ctx.setTransform(1,0,0,1,0,0);
            }
        }
    }
    requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
