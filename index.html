<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roy R. Liu | Portfolio</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #050704; }
        canvas { display: block; cursor: crosshair; }
        #header {
            position: absolute;
            top: 40px; width: 100%; text-align: center;
            color: #f0f0f0; font-family: 'Georgia', serif; font-style: italic;
            letter-spacing: 2px; pointer-events: none;
            text-shadow: 0 0 15px rgba(0,0,0,0.8);
            z-index: 100;
        }
    </style>
</head>
<body>

<div id="header">
    <h1>Welcome to my webpage, click on something.</h1>
</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Performance: Disable alpha for main context

// --- TUNING & OPTIMIZATION ---
const LEAF_COUNT = 3500;    // More leaves
const HORIZON = 0.5;
const DEAD_ZONE = 140;
const DOG_SPEED_SCALAR = 0.9;
const DOG_W = 32, DOG_H = 40;
const GRID_SIZE = 80;       // Spatial partitioning grid size

let mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
let dog = { x: 200, y: 0, vx: 0, vy: 0, row: 3, col: 0, facing: 'right', sitLock: false, targetAction: null };
let leaves = [];
let icons = [];
let spatialGrid = {};

const assets = {
    dog: { src: 'assets/dog.png', img: new Image() },
    fallLeaf: { src: 'assets/fall_leaf.png', img: new Image() },
    springLeaf: { src: 'assets/spring_leaf.png', img: new Image() },
    car: { src: 'assets/car.png', img: new Image(), path: 'racing.html' },
    gamma: { src: 'assets/gamma.png', img: new Image(), path: 'research.html' },
    racket: { src: 'assets/racket.png', img: new Image(), path: 'tennis.html' },
    stock: { src: 'assets/stock.png', img: new Image(), path: 'finance.html' }
};

// --- PRE-RENDERING CACHE ---
const leafCache = document.createElement('canvas');
const lctx = leafCache.getContext('2d');
function preRenderLeaves() {
    leafCache.width = 256; leafCache.height = 256;
    // Draw variants here once assets load to avoid ctx.filter during loop
}

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    dog.y = canvas.height * 0.75;

    Object.keys(assets).forEach(key => assets[key].img.src = assets[key].src);

    const groundTop = canvas.height * HORIZON;
    for(let i=0; i<LEAF_COUNT; i++) {
        leaves.push({
            x: Math.random() * canvas.width,
            y: groundTop + Math.random() * (canvas.height - groundTop),
            z: 0, vz: 0, vx: 0, vy: 0,
            rotX: Math.random() * 6, rotY: Math.random() * 6,
            vrX: 0, vrY: 0,
            type: Math.random() > 0.5 ? 'fallLeaf' : 'springLeaf',
            size: 20 + Math.random() * 50, // Even bigger variety
            waft: Math.random() * 10,
            layer: Math.random(),
            tint: 0.6 + Math.random() * 0.6
        });
    }

    const ids = ['car', 'gamma', 'racket', 'stock'];
    icons = ids.map((id, i) => ({
        id, x: (i+1) * (canvas.width/5), y: groundTop + (canvas.height-groundTop)*0.4,
        rot: (Math.random()-0.5)*0.3, revealed: false, path: assets[id].path
    }));

    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', handleClick);
    requestAnimationFrame(loop);
}

function handleClick() {
    let clickedIcon = icons.find(i => Math.hypot(mouse.x - i.x, mouse.y - i.y) < 100);
    dog.targetAction = { x: mouse.x, y: mouse.y, icon: clickedIcon };
}

function triggerSitExplosion(x, y, icon) {
    dog.sitLock = true;
    setTimeout(() => { dog.sitLock = false; dog.targetAction = null; }, 1200);

    const sitRadius = 115; // 1.1x Dog Size
    leaves.forEach(l => {
        let d = Math.hypot(l.x - x, l.y - y);
        if (d < sitRadius) {
            // Minimal initial horizontal movement
            l.vx = (Math.random() - 0.5) * 1.5; 
            l.vy = (Math.random() - 0.5) * 1.5;
            l.vz = 6 + Math.random() * 6; // Vertical pop remains
            l.vrX = (Math.random()-0.5) * 0.8;
        }
    });
    if (icon) icon.revealed = true;
}

function loop() {
    const groundY = canvas.height * HORIZON;
    ctx.fillStyle = '#050704'; ctx.fillRect(0,0,canvas.width, groundY);
    ctx.fillStyle = '#11150d'; ctx.fillRect(0, groundY, canvas.width, canvas.height-groundY);

    // --- SPATIAL HASHING ---
    spatialGrid = {};
    for (let l of leaves) {
        let gx = Math.floor(l.x / GRID_SIZE);
        let gy = Math.floor(l.y / GRID_SIZE);
        let key = `${gx},${gy}`;
        if (!spatialGrid[key]) spatialGrid[key] = [];
        spatialGrid[key].push(l);
    }

    // --- DOG LOGIC ---
    let targetX = dog.targetAction ? dog.targetAction.x : mouse.x;
    let targetY = dog.targetAction ? dog.targetAction.y : Math.max(groundY + 40, mouse.y);
    let dx = targetX - dog.x, dy = targetY - dog.y;
    let dist = Math.hypot(dx, dy);
    
    if (dog.targetAction && dist < 20) triggerSitExplosion(dog.targetAction.x, dog.targetAction.y, dog.targetAction.icon);

    if (!dog.sitLock) {
        if (dog.targetAction) {
            let angle = Math.atan2(dy, dx);
            dog.vx = Math.cos(angle) * 8.5 * DOG_SPEED_SCALAR;
            dog.vy = Math.sin(angle) * 8.5 * DOG_SPEED_SCALAR;
        } else if (dist > DEAD_ZONE) {
            let speedMult = (dist > 180) ? 0.05 : 0.02;
            dog.vx = dx * speedMult * DOG_SPEED_SCALAR;
            dog.vy = dy * speedMult * DOG_SPEED_SCALAR;
        } else { dog.vx *= 0.8; dog.vy *= 0.8; }
    } else { dog.vx *= 0.6; dog.vy *= 0.6; }
    
    dog.x += dog.vx; dog.y += dog.vy;
    let moving = Math.abs(dog.vx) + Math.abs(dog.vy) > 0.3;
    if (moving) dog.facing = dog.vx > 0 ? 'right' : 'left';

    // --- LEAF PHYSICS & COLLISIONS ---
    for (let l of leaves) {
        let p = 0.5 + (l.y/canvas.height);
        
        // Dog Interaction: High Randomness to prevent sticking
        let dDog = Math.hypot(l.x - dog.x, l.y - (dog.y + 12));
        // Dog sometimes moves more than one layer (layer > 0.5)
        let layerThreshold = Math.random() > 0.9 ? 0.3 : 0.7; 
        
        if (dDog < 55*p && moving && !dog.sitLock && l.layer > layerThreshold) {
            let randAngle = Math.atan2(l.y - dog.y, l.x - dog.x) + (Math.random()-0.5) * 2;
            l.vx += Math.cos(randAngle) * 4;
            l.vy += Math.sin(randAngle) * 2;
            l.vz += 0.05;
            l.layer = Math.min(1, l.layer + 0.1); // Moving leaves rise to top
        }

        // Inter-leaf Collisions (Spatial Hash optimized)
        if (l.vz > 0 || Math.abs(l.vx) > 0.5) {
            let gx = Math.floor(l.x / GRID_SIZE);
            let gy = Math.floor(l.y / GRID_SIZE);
            let neighbors = spatialGrid[`${gx},${gy}`] || [];
            for (let other of neighbors) {
                if (other === l) continue;
                let d = Math.hypot(l.x - other.x, l.y - other.y);
                if (d < 15) {
                    other.vx += l.vx * 0.2;
                    other.vy += l.vy * 0.2;
                    // Swap layers occasionally on impact
                    if (Math.random() > 0.8) [l.layer, other.layer] = [other.layer, l.layer];
                }
            }
        }

        // Movement Update
        if (l.z > 0 || Math.abs(l.vx) > 0.1) {
            l.x += l.vx; l.y += l.vy; l.z += l.vz;
            l.rotX += l.vrX; l.rotY += l.vrY;
            if (l.z > 0) {
                l.vz -= 0.39; // Gravity
                l.vx *= 0.96; l.vy *= 0.96;
                l.vx += Math.sin(Date.now()*0.005 + l.waft) * 0.5; // Randomness from falling
            } else {
                l.z = 0; l.vz = 0; l.vx *= 0.5; l.vy *= 0.5;
            }
            if (l.y < groundY) l.y = groundY + 5;
            if (l.y > canvas.height) l.y = canvas.height - 5;
        }
    }

    // --- SORTED RENDER ---
    let renderList = [...leaves, { isDog: true, y: dog.y }].sort((a,b) => a.y - b.y);
    renderList.forEach(obj => {
        let p = 0.5 + (obj.y/canvas.height);
        if (obj.isDog) {
            let dW = 135 * p, dH = 160 * p;
            if (assets.dog.img.complete) {
                dog.col = (dog.sitLock || !moving) ? (dog.facing === 'right' ? 0 : 2) : (dog.facing === 'right' ? 0 : 2) + (Math.floor(Date.now()/120)%2);
                dog.row = (dog.sitLock || !moving) ? 3 : 1;
                ctx.drawImage(assets.dog.img, dog.col*DOG_W, dog.row*DOG_H, DOG_W, DOG_H, dog.x - dW/2, dog.y - dH*0.7, dW, dH);
            }
        } else {
            let l = obj;
            if (assets[l.type].img.complete) {
                ctx.save();
                ctx.translate(l.x, l.y - l.z);
                ctx.scale(p * Math.sin(l.rotX), p * Math.cos(l.rotY));
                ctx.rotate(l.rotX);
                // Draw leaf without expensive filter during loop
                ctx.drawImage(assets[l.type].img, 0, 0, 16, 16, -l.size/2, -l.size/2, l.size, l.size);
                ctx.restore();
            }
        }
    });

    requestAnimationFrame(loop);
}

init();
</script>
</body>
</html>
