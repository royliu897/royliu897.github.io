<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roy R. Liu | Interactive Portfolio</title>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #050704; }
        canvas { display: block; }
        
        #backToNormal {
            position: absolute; top: 20px; left: 20px;
            padding: 10px 18px; background: rgba(255, 255, 255, 0.1);
            color: #f0f0f0; text-decoration: none; font-family: 'Georgia', serif;
            font-style: italic; font-size: 0.9rem; border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px; backdrop-filter: blur(5px); z-index: 200; transition: background 0.3s;
        }
        #backToNormal:hover { background: rgba(255, 255, 255, 0.2); }

        /* FOOTER STYLING */
        #footer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 10%;
            background: #b8a47e; /* Sand Tan Color */
            border-top: 1px solid #8f7d5c;
            display: flex; align-items: center; justify-content: center;
            gap: 50px; /* Spread out elements */
            z-index: 100;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
        }

        /* Footer Text */
        #footer span {
            color: #ffffff; 
            font-family: 'Georgia', serif; 
            font-style: italic; 
            font-size: 1.1rem; /* Slightly bigger */
            letter-spacing: 1px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.4); /* Shadow to make white pop on sand */
        }

        /* Icons Container */
        .legend-icons { display: flex; gap: 40px; align-items: center; } /* Spread out icons */
        .legend-icons img {
            height: 36px; width: auto; opacity: 0.85; 
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3));
            transition: transform 0.2s;
            cursor: pointer;
        }
        .legend-icons img:hover { transform: scale(1.1); opacity: 1; }

        /* Reset Button (Now inside footer) */
        #resetBtn {
            padding: 8px 16px; 
            background: rgba(255,255,255,0.2);
            color: #fff; 
            border: 1px solid rgba(255,255,255,0.6);
            font-family: 'Georgia', serif; 
            font-size: 0.9rem;
            cursor: pointer; 
            border-radius: 4px; 
            transition: background 0.2s;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        #resetBtn:hover { background: rgba(255,255,255,0.4); }

    </style>
</head>
<body>

<a href="index.html" id="backToNormal">‚Üê Professional View</a>

<div id="footer">
    <span>Find and click on these items:</span>
    
    <div class="legend-icons">
        <img src="assets/car.png" alt="Racing" title="Racing">
        <img src="assets/gamma.png" alt="Research" title="Research">
        <img src="assets/racket.png" alt="Tennis" title="Tennis">
        <img src="assets/stock.png" alt="Finance" title="Finance">
    </div>

    <button id="resetBtn">Reset Leaves</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// --- ENGINE TUNING ---
const LEAF_COUNT = 3500;    
const HORIZON_RATIO = 0.45; 
const BOTTOM_MARGIN = 0.1;  
const DEAD_ZONE = 100;       
const GRAVITY = 0.39;
const DOG_W = 32, DOG_H = 40;
const V_SCALE = 0.8;

// Select Sky Folder (1-8) ONCE on load
const SKY_ID = Math.ceil(Math.random() * 8);

let mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
let dog = { x: 200, y: 0, vx: 0, vy: 0, row: 1, col: 0, facing: 'right', sitLock: false, targetAction: null };
let leaves = [];
let icons = [];
let trees = []; 
let lastTime = 0;

const assets = {
    dog: { src: 'assets/dog.png', img: new Image() },
    fallLeaf: { src: 'assets/fall_leaf.png', img: new Image() },
    springLeaf: { src: 'assets/spring_leaf.png', img: new Image() },
    treeGreen: { src: 'assets/tree_green.png', img: new Image() },
    treeFall: { src: 'assets/tree_fall.png', img: new Image() },
    complete_floor: { src: 'assets/complete_floor.png', img: new Image() },
    
    car: { src: 'assets/car.png', img: new Image(), path: 'lhr.html' },
    gamma: { src: 'assets/gamma.png', img: new Image(), path: 'research.html' },
    racket: { src: 'assets/racket.png', img: new Image(), path: 'tennis.html' },
    stock: { src: 'assets/stock.png', img: new Image(), path: 'stocks.html' },

    // Sky Layers
    sky1: { src: `assets/Clouds/Clouds ${SKY_ID}/1.png`, img: new Image(), speed: 0.0 },
    sky2: { src: `assets/Clouds/Clouds ${SKY_ID}/2.png`, img: new Image(), speed: 0.05 },
    sky3: { src: `assets/Clouds/Clouds ${SKY_ID}/3.png`, img: new Image(), speed: 0.1 },
    sky4: { src: `assets/Clouds/Clouds ${SKY_ID}/4.png`, img: new Image(), speed: 0.2 }
};

function initLeaves() {
    leaves = [];
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
    for(let i=0; i<LEAF_COUNT; i++) {
        leaves.push({
            x: Math.random() * canvas.width,
            y: topLimit + Math.random() * (botLimit - topLimit),
            z: 0, vz: 0, vx: 0, vy: 0,
            rotX: Math.random() * 6, rotY: Math.random() * 6,
            vrX: 0, vrY: 0,
            type: Math.random() > 0.5 ? 'fallLeaf' : 'springLeaf',
            frame: Math.floor(Math.random()*5),
            size: 40 + Math.random() * 50, 
            waft: Math.random() * 10,
            layer: Math.random(),
            skew: (Math.random() - 0.5) * 0.1,
            chaos: 0.5 + Math.random()
        });
    }
}

function initEnvironment() {
    trees = [];
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
    
    for(let i=0; i<5; i++) {
        const isFall = Math.random() > 0.5;
        const type = isFall ? 'treeFall' : 'treeGreen';
        const frameIndex = Math.floor(Math.random() * 15);
        const sx = (frameIndex % 4) * 128;
        const sy = Math.floor(frameIndex / 4) * 128;
        const pad = 50;
        trees.push({
            type: type, sx: sx, sy: sy,
            x: pad + Math.random() * (canvas.width - pad*2),
            y: topLimit + pad + Math.random() * (botLimit - topLimit - pad), 
            scale: 2.5 + Math.random() * 1.5, 
            collisionRadius: 40
        });
    }
}

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    dog.y = canvas.height * 0.7;
    Object.keys(assets).forEach(key => assets[key].img.src = assets[key].src);
    initLeaves();
    initEnvironment();
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
    const ids = ['car', 'gamma', 'racket', 'stock'];
    icons = ids.map((id, i) => ({
        id, x: (i+1) * (canvas.width/5), y: topLimit + (botLimit - topLimit) * 0.4,
        rot: (Math.random()-0.5)*0.2, revealed: false, path: assets[id].path
    }));
    window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
    window.addEventListener('mousedown', e => {
        const topLimit = canvas.height * HORIZON_RATIO;
        const botLimit = canvas.height * (1 - BOTTOM_MARGIN);
        if (e.clientY < topLimit || e.clientY > botLimit) return;
        let clickedIcon = icons.find(i => Math.hypot(mouse.x - i.x, mouse.y - i.y) < 80);
        dog.targetAction = { x: mouse.x, y: mouse.y, icon: clickedIcon };
    });
    document.getElementById('resetBtn').onclick = (e) => { e.stopPropagation(); initLeaves(); };
    requestAnimationFrame(loop);
}

// RESTORED: Original physics logic with Preloading fix
function triggerSitExplosion(x, y, icon) {
    dog.sitLock = true;
    dog.vx = 0; dog.vy = 0; dog.x = x; dog.y = y;

    if (icon) {
        icon.revealed = true;
        
        // 1. Fetch the page (Preload)
        const loadPage = fetch(icon.path)
            .then(response => {
                if (!response.ok) throw new Error("Network response was not ok");
                return response;
            })
            .catch(error => {
                console.log("Preload failed or local file, proceeding anyway");
            });

        // 2. Minimum wait time for animation (500ms)
        const minWait = new Promise(resolve => setTimeout(resolve, 500));

        // 3. Wait for BOTH loading to finish and animation to finish
        Promise.all([loadPage, minWait]).then(() => {
            window.location.href = icon.path;
        });
        
        // Note: We do NOT unlock the dog here if it's an icon, 
        // because we are about to leave the page.
    } else {
        // Only unlock if it wasn't an icon click
        setTimeout(() => { dog.sitLock = false; dog.targetAction = null; }, 500);
    }

    const sitRadius = 85; 
    leaves.forEach(l => {
        let dx = l.x - x; let dy = l.y - y;
        let d = Math.hypot(dx, dy);
        if (d < sitRadius) {
            let angle = Math.atan2(dy, dx);
            l.vx += (Math.cos(angle) * 0.6) + (Math.random() - 0.5) * 0.3;
            l.vy += Math.sin(angle) * 0.4;
            l.vz += (0.8 + Math.random() * 0.2) * V_SCALE; 
            l.vrX = (Math.random() - 0.5) * 0.2; 
            l.layer = 1.0; 
        }
    });
}

// RESTORED: Soft boundary targeting
function getSoftTargetY(mouseY, topLimit, botLimit) {
    if (mouseY >= topLimit && mouseY <= botLimit) return mouseY;
    let factor = 0.15;
    if (mouseY < topLimit) {
        let over = (topLimit - mouseY) * factor;
        return topLimit - (Math.atan(over / 50) * 15); 
    } else {
        let over = (mouseY - botLimit) * factor;
        return botLimit + (Math.atan(over / 50) * 15);
    }
}

function drawSkyLayer(layer, dt, time) {
    if (!layer.img.complete) return;
    const imgRatio = layer.img.width / layer.img.height;
    const drawH = canvas.height; 
    const drawW = drawH * imgRatio;
    let wind = time * 0.02 * layer.speed; 
    let parallax = dog.x * 0.2 * layer.speed;
    let totalX = -(wind + parallax) % drawW;
    ctx.drawImage(layer.img, totalX, 0, drawW, drawH);
    ctx.drawImage(layer.img, totalX + drawW, 0, drawW, drawH);
    if (totalX + drawW < canvas.width) {
        ctx.drawImage(layer.img, totalX + drawW * 2, 0, drawW, drawH);
    }
}

function loop(time) {
    const dt = Math.min((time - lastTime) / 16.67, 2) || 1;
    lastTime = time;
    const topLimit = canvas.height * HORIZON_RATIO;
    const botLimit = canvas.height * (1 - BOTTOM_MARGIN);

    // 1. SKY (Background Layers)
    ctx.fillStyle = '#87CEEB'; 
    ctx.fillRect(0, 0, canvas.width, topLimit);
    drawSkyLayer(assets.sky1, dt, time);
    drawSkyLayer(assets.sky2, dt, time);
    drawSkyLayer(assets.sky3, dt, time);
    drawSkyLayer(assets.sky4, dt, time);

    // 2. GROUND BACKGROUND
    if (assets.complete_floor.img.complete) {
        ctx.drawImage(assets.complete_floor.img, 0, topLimit, canvas.width, botLimit - topLimit);
    } else {
        ctx.fillStyle = '#11150d'; 
        ctx.fillRect(0, topLimit, canvas.width, botLimit - topLimit);
    }
    
    // Black bar at bottom (behind the UI Footer)
    ctx.fillStyle = '#000000'; 
    ctx.fillRect(0, botLimit, canvas.width, canvas.height - botLimit);

    // --- DOG LOGIC (Restored Soft Target Y) ---
    let targetX = dog.targetAction ? dog.targetAction.x : mouse.x;
    let rawTargetY = dog.targetAction ? dog.targetAction.y : getSoftTargetY(mouse.y, topLimit, botLimit);
    let targetY = Math.max(topLimit + 5, Math.min(botLimit - 5, rawTargetY));

    let dx = targetX - dog.x, dy = targetY - dog.y;
    let dist = Math.hypot(dx, dy);
    
    // CRITICAL FIX: Added !dog.sitLock check to prevent loop spasm
    if (dog.targetAction && dist < 15 && !dog.sitLock) {
        triggerSitExplosion(dog.targetAction.x, dog.targetAction.y, dog.targetAction.icon);
    }

    if (!dog.sitLock) {
        if (dog.targetAction) {
            let angle = Math.atan2(dy, dx);
            dog.vx = Math.cos(angle) * 9; dog.vy = Math.sin(angle) * 9;
            dog.facing = dog.vx > 0 ? 'right' : 'left';
        } else if (dist > DEAD_ZONE) {
            dog.vx = dx * 0.05; dog.vy = dy * 0.05;
            dog.facing = dog.vx > 0 ? 'right' : 'left';
        } else {
            dog.vx *= 0.8; dog.vy *= 0.8;
            // Only update facing if user is actively moving mouse
            if(Math.abs(mouse.x - dog.x) > 10) dog.facing = (mouse.x > dog.x) ? 'right' : 'left';
        }
        
        // --- TREE COLLISION CHECK ---
        let nextX = dog.x + dog.vx * dt;
        let nextY = dog.y + dog.vy * dt;
        let collided = false;
        for(let t of trees) {
            let dTree = Math.hypot(nextX - t.x, nextY - t.y);
            if(dTree < t.collisionRadius) {
                dog.vx *= 0.5; dog.vy *= 0.5; 
                collided = true;
                let angle = Math.atan2(dog.y - t.y, dog.x - t.x);
                dog.x = t.x + Math.cos(angle) * (t.collisionRadius + 1);
                dog.y = t.y + Math.sin(angle) * (t.collisionRadius + 1);
            }
        }
    }
    
    if (!dog.sitLock) {
        dog.x += dog.vx * dt; dog.y += dog.vy * dt;
    }

    let moving = Math.hypot(dog.vx, dog.vy) > 0.4;
    
    if (dog.sitLock) { 
        dog.row = 3; dog.col = (dog.facing === 'right' ? 0 : 2) + Math.floor(Date.now()/300)%2; 
    } else if (!moving) { 
        dog.row = 1; dog.col = (dog.facing === 'right' ? 0 : 2) + Math.floor(Date.now()/500)%2; 
    } else { 
        dog.row = (dog.facing === 'right' ? 6 : 7); dog.col = Math.floor(Date.now() / 100) % 4; 
    }

    // --- RENDER SORTING ---
    let renderList = [
        ...leaves.map(l => ({ type: 'leaf', y: l.y, d: l })),
        ...icons.map(i => ({ type: 'icon', y: i.y, d: i })),
        ...trees.map(t => ({ type: 'tree', y: t.y, d: t })), 
        { type: 'dog', y: dog.y }
    ].sort((a,b) => a.y - b.y);

    for (let obj of renderList) {
        let p = 0.5 + (obj.y/canvas.height);
        
        if (obj.type === 'leaf') {
            let l = obj.d;
            let dDog = Math.hypot(l.x - dog.x, l.y - (dog.y + 10));
            // Interaction
            if (dDog < 50*p && moving && !dog.sitLock) {
                if (l.layer > 0.7) { 
                    let pushAngle = Math.atan2(l.y - dog.y, l.x - dog.x);
                    l.vx += (Math.cos(pushAngle) * 1.5) + (Math.random() - 0.5) * 0.5;
                    l.vy += Math.sin(pushAngle) * 0.8;
                    l.vz += (0.08 + (Math.hypot(dog.vx, dog.vy) * 0.04)) * V_SCALE;
                    l.vrX *= 0.85; 
                }
                if (Math.random() > 0.5) l.layer = Math.min(1.0, l.layer + 0.08); 
            }
            // Physics Update (Restored exact damping factors)
            if (l.z > 0 || Math.abs(l.vx) > 0.1) {
                l.x += l.vx * dt; l.y += l.vy * dt; l.z += l.vz * dt;
                l.rotX += l.vrX * dt; l.rotY += l.vrY * dt;
                if (l.z > 0) {
                    l.vz -= GRAVITY * dt;
                    if (l.vz > 0) { l.vx *= 0.99; l.vy *= 0.99; l.vrX *= 0.96; } 
                    else { 
                        l.vx *= 0.92; l.vy *= 0.92;
                        l.vx += Math.sin(Date.now()*0.003 + l.waft) * (0.6 * l.chaos);
                    }
                } else { l.z = 0; l.vz = 0; l.vx *= 0.5; l.vy *= 0.5; l.vrX = 0; }
                if (l.x < 0) { l.x = 0; l.vx *= -1; } if (l.x > canvas.width) { l.x = canvas.width; l.vx *= -1; }
                if (l.y < topLimit) { l.y = topLimit; l.vy *= -1; } if (l.y > botLimit) { l.y = botLimit; l.vy *= -1; }
            }
            if (assets[l.type].img.complete) {
                ctx.setTransform(p * Math.sin(l.rotX), l.skew, 0, p * Math.cos(l.rotY), l.x, l.y - l.z);
                ctx.drawImage(assets[l.type].img, l.frame*16, 0, 16, 16, -l.size/2, -l.size/2, l.size, l.size);
            }
        } else if (obj.type === 'tree') {
            let t = obj.d;
            if (assets[t.type].img.complete) {
                let renderSize = 128 * t.scale * p;
                ctx.setTransform(1, 0, 0, 1, t.x, t.y);
                ctx.drawImage(
                    assets[t.type].img, 
                    t.sx, t.sy, 128, 128, 
                    -renderSize/2, -renderSize + (10 * p), renderSize, renderSize 
                );
            }
        } else if (obj.type === 'icon') {
            let i = obj.d;
            if (assets[i.id].img.complete) {
                ctx.setTransform(p, 0, 0, p, i.x, i.y); ctx.rotate(i.rot);
                ctx.drawImage(assets[i.id].img, -60, -60, 120, 120);
                if (i.revealed) {
                    ctx.setTransform(1, 0, 0, 1, i.x, i.y + 80*p);
                    ctx.fillStyle = "white"; ctx.font = "italic 15px Georgia"; ctx.textAlign = "center";
                    ctx.fillText(i.id.toUpperCase(), 0, 0);
                }
            }
        } else {
            if (assets.dog.img.complete) {
                let dW = 135 * p, dH = 160 * p;
                ctx.setTransform(1, 0, 0, 1, dog.x, dog.y);
                ctx.drawImage(assets.dog.img, dog.col*DOG_W, dog.row*DOG_H, DOG_W, DOG_H, -dW/2, -dH*0.7, dW, dH);
            }
        }
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
    }
    requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
